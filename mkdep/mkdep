#!/usr/bin/env python

import os, sys, getopt, string
import libmkdep, globals

def usage():
    print \
"""
Fortran dependency generator for GNU Makefiles.

Usage:

   mkdep [optional arguments see below] <filelist>

  reset          deletes temporary files created by mkdep
  -a <file name> assemble all source files (not include) into the file <file name>
  -b turn off the default behaviour, that all objects end up in the build directory.
     this is necessary if your project has files with identical name, but in different
     directories.
  -c Insert defaults for all missing optional columns in project file
  -d Turn on debugging output
  -g Insert missing default group names into the project file
  -h show this message
  -i <file>
     File is a text file with a list of directories to search for include files.
     The latter directories take precedence over the first.
     if not specified mkdep/cpp will search all directories in the project files.
  -L Generate a Makefile with support for mklib (use for large projects)
  -m write a list of modules and their source file to .mkdep_modmap
  -p <path>
     specify a path to be prepended to the links to the source files in the html tree file.
  -r <dir> 
     Specify a different root dir. This path will be prepended to all filenames in <filelist>
  -s View the stripped statements just as the internal matching routines see them
  -t <title>
     Generate call tree. Off by default as this takes extra time. title will be used on the
     autogenerated html page and its file name.
  -w show warnings

 --fc <compiler>   specify the name of the Fortran compiler to be used in the Makefile
 --cc <compiler>   specify the name of the C compiler to be used in the Makefile
 --cpp <cpp path>  specify the full path to the c preprocessor to be used. 
 --cppflags <flags>     specify the flags for cpp, e.g. all defines that are required,
                   or override include paths.
 --treetop NAME    if there is no main program, it is possible to choose a root for
                   the tree (NAME), otherwise full trees will be made for each routine.


<filelist> is a text file where lines contain the full path to a
source file in the first column. Blank lines, or lines with # at the
beginning are ignored. Columns 2-4 are optional, and may be used to
override default settings;

Column 2: 
   a user defined string/label used to separate groups of object files
   that e.g. need to be compiled with special flags. default value 'opt'.
   
Column 3, override file type:
   free      free form fortran
   fixed     std fixed form fortran
   fixed132  fixed form fortran with extended lines
   C         C
Column 4, override file type:
   source    the file should be compiled
   include   the file is an included file

Helge Avlesen <avle@bccs.uib.no>  para//ab
"""
    sys.exit(1)


    
## Initialization...

use_mklib=0         # generate calls to mklib in the makefile
viewsrc=0           # print stripped src to screen; 1=on, 0=off
incfile=''          # the list of include directories
lines = 0           # count parsed lines
f=0                 # file counter
warning=0           # if duplicate modules are found, warning=1
warningmap={}       # file list of other defs.
modnamesize=14
rootdir=''          # prepend this path to all file names in the project file
f95='f90'
cc='cc'
cppcommand=""
cppflags="-P -traditional"   # the default flags to use for cpp (assume GNU cpp)

# 50 erase characters... if anyone reading this knows a prettier way do not hesitate...

erase_50 = "\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\
\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\
\x08\x08\x08\x08\x08\x08\x08\x08\x08"

## cleanup

if len(sys.argv)>1:
    if sys.argv[1]=="reset":
        f=open(".mkdep_objects","w")
        f.write(" ")
        f.close()
        f=open(".mkdep_dependencies","w")
        f.write(" ")
        f.close()
        f=open(".mkdep_rules","w")
        f.write(" ")
        f.close()
        try:
            os.remove(".files")
            os.remove(".mkdep_includes")
            os.remove(".mkdep_restart_file")
        except OSError:
            pass
        if os.access('build',os.F_OK)==0:
            os.mkdir('build')
        
        print "reset/initialize mkdep background data. you should now run 'make dep' or 'mkdep <project file>'"        
        sys.exit()
    
## override the defaults with command line arguments

try:
    opts, args = getopt.getopt(sys.argv[1:], "a:bcdghi:Lmp:r:st:w", \
                                   ['fc=','cc=','help','cpp=','cppflags=','treetop='])
    if opts<>[]:
        for opt, value in opts:            
            if opt in ("-h","--help"):
                usage()
                sys.exit(1)
            if opt == "-i":
                incfile = value
            if opt == "-a":
                libmkdep.assemblefile = value
            if opt == "-b":
                globals.use_build_dir=0
            if opt == "-r":
                rootdir = value
            if opt == "-L":
                use_mklib=1
            if opt == "-d":
                libmkdep.debug=1
            if opt == "-p":
                libmkdep.root_path=value
            if opt == "-w":
                libmkdep.show_warnings=1
            if opt == "-t":
                libmkdep.calltree_title=value
                globals.calltree=1
            if opt == "-g":
                libmkdep.insert_group=1
            if opt == "-c":
                libmkdep.full_classify=1
	    if opt == "-m":
		libmkdep.dump_modmap=1
            if opt == "-s":
                viewsrc=1
	    if opt == "--fc":
		f95=value
	    if opt == "--cc":
		cc=value
            if opt == "--cppflags":
                cppflags = value
            if opt == "--cpp":
                cppcommand = value
            if opt == "--treetop":
                libmkdep.treetop = value
                
except getopt.GetoptError:
    print "\nhm. mkdep is very confused by this argument list:"
    print sys.argv[1:]
    print "please try something else. also see 'mkdep -h'\n"
    sys.exit(2)
    
if len(args)<1 or args[0]=="":
    print "\nno project file given?"
    usage()
    sys.exit(2)

project_file=args[0]


### Parse the project file and reload the current dependency map from .mkdep_restart_file

includepath = libmkdep.classify_files(project_file, incfile, rootdir)

if cppcommand.strip() <> "type":
    cppflags += " " + globals.incpathstring


### First pass. look up definitions of e.g. modules and subprograms.

print "\nScanning source file:                                                   ",

cppwarn=0

for (filename,(type, is_include, compflag, mtime, deps, reparse, deleted)) in globals.clean_source_files2.items():
    if not reparse:
        continue
    
    f+=1
    print erase_50 + filename.ljust(49),

    out = libmkdep.getsrc(cppcommand, cppflags, filename)
    srclines = out.split('\n')

    if not is_include:
        registred=0
        for key in globals.object_files.keys():
            if filename in globals.object_files[key]:
                registred=1
                if key <> compflag:
                    #file excists, but has new group
                    i = globals.object_files[key].index(filename)
                    del globals.object_files[key][i]
                    if globals.object_files.has_key(compflag):
                        if not filename in globals.object_files[compflag]:
                            globals.object_files[compflag].append(filename)
                    else:
                        globals.object_files[compflag]=[filename]
        if not registred:
            if globals.object_files.has_key(compflag):
                globals.object_files[compflag].append(filename)
            else:
                globals.object_files[compflag]=[filename]

    dotpos = filename.rfind('.')
    suffix = filename[dotpos+1:]
    if suffix not in globals.suffixes:
        globals.suffixes.append(suffix)
    
    long_line = ""      # the line that will be sent to the splitter
    stored_line = ""    # the statement following long_line
    cline = 0           # current source line number
    file_tabs=[]        # a list of source lines on which tabs were found.
    cont_cpp=[]         # a list of line numbers with possible cpp crossing
    last_line=0         # if true, fline is the last line of a file.

    current_host=""
    
    for fline in srclines:
        cline += 1
        if libmkdep.debug: print "\n"
        
        ## the scanner. feed each line into the joiner's
        
        if type=="free":
            long_line, get_next = libmkdep.join_and_strip_free(fline, long_line)
        elif type in ["fixed","fixed132"]:
            last_line = cline==len(srclines)
            long_line, get_next, stored_line, warning_flag = libmkdep.join_and_strip_fixed(\
                fline, long_line, stored_line, last_line, type=type)
        else:
            long_line, get_next = fline.strip(), 0

        if get_next:
            continue

        long_line = libmkdep.strip_strings(long_line)
        ## the splitter. split each line at ;
        ## this gives us one statement per line

        for line in long_line.split(";"):
            line = line.strip()
            if line == "":
                continue
            lines += 1

            line = line.upper()

            # we are now left with very naked fortran

            fortran_names = libmkdep.match_fortran_name.findall(line)

            if viewsrc: print "pass1 %5.5d"%cline + " " + line
            
            ## first look for module definitions
            name = libmkdep.match_module(fortran_names)
            
            if name<>"":
                in_module=1
                if globals.module_map.has_key(name):
                    if filename <> globals.module_map[name][0]:
                    ## this module is already defined elsewhere, give a warning
                        print "while scanning ",filename,":"
                        print "found duplicate module name:",name, ", already in file", globals.module_map[name][0],
                        warning=1
                        if warningmap.has_key(name):
                            warningmap[name].append(('\n            '+filename.strip()))
                        else:
                            warningmap[name]=[(name + '\nfirst definition: ' + globals.module_map[name][0] +\
                                               '\nother definitions:\n            '), filename.strip()]
		#else:
                    ## use first module found
                    #libmkdep.module_map[name] = (filename, [], [])

                ## use last module found
                globals.module_map[name] = (filename, [], [])


	    name = libmkdep.match_program_def(fortran_names)
	    if name<>"":
		if globals.calltree: in_program, current_program = libmkdep.add2dict(globals.routines, name, (filename, [], []))
		in_program, current_program = libmkdep.add2dict(globals.programs, name, (filename, [], []))
		libmkdep.register_main_program(filename)


            if globals.calltree:

                ## in this pass the main task is to find the routine
                ## names, and the mapping between routine name and the
                ## file name. we should also figure out which
                ## namespace a routine name belongs to. we have the
                ## global namespace, and namespaces for modules and
                ## routines.
                ## initially we only do f77.

                #contained = match_contained(line)
                #if contained:
                #    if in_routine:
                #        current_host=current_routine
                #    if in_module:
                #        current_host=current_module

                name = libmkdep.match_subroutine_def(fortran_names)
		
                # if in a module or subprog, add name to local namespace, otherwise to the global.
		
                if name<>"":
                    in_routine, current_routine = libmkdep.add2dict(globals.routines, name, (filename, [], []))

                name = libmkdep.match_function_def(fortran_names)
                if name<>"":
                    in_routine, current_routine = libmkdep.add2dict(globals.routines, name, (filename, [], []))
                    in_routine, current_routine = libmkdep.add2dict(globals.functions, name, (filename, [], []))

                name = libmkdep.match_module_end(fortran_names)
		if name <> "":
                    current_host=""
                    contained=0

		name = libmkdep.match_end_subprogram(fortran_names)
		if name <> "":
		    in_routine=0

		if libmkdep.match_end(fortran_names):
		    ## yeah. it is possible to have a program with no program statement.
		    ## but a single end reveals it... unless we are a subroutine or function
		    #if not in_routine:
		    #    libmkdep.register_main_program(filename)		    
		    current_program=""
		    in_routine=0
		    contained=0



        ## line done, reset
        long_line=""



print "\n\n",lines,"statements,\n",len(globals.module_map),"modules (see .mkdep_modmap if you use -m option)"

if globals.calltree:
    print len(globals.routines)-len(globals.functions)-len(globals.programs),"subroutines (see .mkdep_routines)"
    print len(globals.functions),"functions"
    print len(globals.programs),"programs"
    
    rfile=open('.mkdep_routines','w')
    names=globals.routines.keys()
    names.sort()
    for name in names:
        rfile.write( name.ljust(20) + globals.routines[name][0] + "\n" )
    rfile.close()
    print "\nHTML call tree stored in "+libmkdep.calltree_title+".html"
    print "see .mkdep_trees for the ascii call tree(s)"
print ""

if globals.object_files.has_key('MAIN'):
    if len(globals.object_files['MAIN']) > 1:
        print "Looks like there are several files with main programs;"
        for file in globals.object_files['MAIN']:
            print "  ",file
        print "you may want to remove all but one from the project file\n"

if warning:
    wmfile = open('.mkdep_warnings','w')
    wmfile.write(("A list of modules with multiple definitions. You should comment out/remove\n"+\
    "source files that contain the duplicate definition, from the list of source\n"+\
    "files given in '"+sys.argv[1]+"' \n\n"))
    for key in warningmap:
        wmfile.write(( string.join(warningmap[key]) + "\n" ))
    wmfile.close()

    print "\nWarning:",len(warningmap),"modules were defined in several files, see the file"
    print "         .mkdep_warnings for a list."


print """
We now scan files again for INCLUDE and USE statements. Lists of
object files and their dependencies for direct inclusion in a GNU
Makefile are stored in .mkdep_objects and .mkdep_dependencies
respectively.
"""

print "scanning..."
print "     ",

lines=0
f=0

for (filename,(type, is_include, compflag, mtime, deps, reparse, deleted)) in globals.clean_source_files2.items():
    if not reparse:
        continue
    f+=1

    print erase_50 + filename.ljust(49),


    out = libmkdep.getsrc(cppcommand, cppflags, filename)
    srclines = out.split('\n')

    deps=[]             # a list of files that the current file depend on
    long_line = ""      # the line that will be sent to the splitter
    stored_line = ""    # the statement following long_line
    cline = 0           # current source line number
    file_tabs=[]        # a list of source lines on which tabs were found.
    cont_cpp=[]         # a list of line numbers with possible cpp crossing
    last_line=0         # if true, fline is the last line of a file.
    
    for fline in srclines:
        cline += 1
        
        ## the scanner. feed each line into the joiner's
        
        if type=="free":
            long_line, get_next = libmkdep.join_and_strip_free(fline, long_line)

        elif type in ["fixed","fixed132"]:
            last_line = cline==len(srclines)
            
            long_line, get_next, stored_line, warning_flag = libmkdep.join_and_strip_fixed(\
                fline, long_line, stored_line, last_line, type=type)

            if warning_flag & 2**0: file_tabs.append(cline)
            if warning_flag & 2**1: cont_cpp.append(cline)
        else:
            long_line, get_next = fline.strip(), 0

        if get_next:
            continue


        ########### lets try to find include files before we strip off strings...
        tmp_line = long_line
        tmp_line = tmp_line.strip()
        name = libmkdep.match_include(tmp_line, includepath)
        if name<>"":
            try:
                deps.index(name)
            except ValueError:
                deps.append(name)               
        ###########


        long_line = libmkdep.strip_strings(long_line)
        ## the splitter. split each line at ;
        ## this gives us one statement per line

        for line in long_line.split(";"):
            line = line.strip()

            if line == "":
                continue
            lines+=1

            #line = libmkdep.strip_strings(line)
            line = line.upper()

            fortran_names = libmkdep.match_fortran_name.findall(line)
            
            if viewsrc: print "pass2 %5.5d"%cline + " " + line
            
            ## now we can feed the stripped statement lines into the
            ## matchers if we would like to parse other fortran
            ## constructs this is a good place.

            #name = libmkdep.match_include(line, includepath)

            #if name<>"":
            #    try:
            #        deps.index(name)
            #    except ValueError:
            #        deps.append(name)               
        
            name, liste = libmkdep.match_use(line, globals.module_map, filename)

            # add liste to current local namespace

            if name not in ["",filename]:
                dotpos = name.rfind(".")
                objf = name[:dotpos] + ".o"
                try:
                    deps.index(objf)
                except ValueError:
                    deps.append(objf)


            if globals.calltree:
                declaration_line = 0
                name = libmkdep.match_subroutine_def(fortran_names)
                if name<>"":
                    in_routine=1
                    current_routine=name
                    declaration_line =1
                name = libmkdep.match_function_def(fortran_names)
                    
                if name<>"":
                    in_routine=1
                    current_routine=name
                    declaration_line =1                    
                name = libmkdep.match_program_def(fortran_names)
                if name<>"":
                    in_routine=1
                    current_routine=name
                    declaration_line =1
                
                if libmkdep.match_end_subprogram(fortran_names):
                    current_routine=""
                    in_routine=0
                    contained=0
                    declaration_line =1                    
                
                # there is only one way to end a module def:
                #in_module = libmkdep.match_module_end(line)
                #if not in_module:
                #    current_host=""
                #    contained=0

                name = libmkdep.match_subroutine_call(fortran_names)
                if name<>"":
                    if current_routine=="":
                        print "\nhm. most likely not in a routine, but found calls to subroutine ",name
                        print "will not add call to tree. file=",filename,"line="
                        print line
                    else:
                        libmkdep.add2tree(globals.routines, current_routine, [name])

                # look for function calls on all lines except beginning or end of definition
                if not declaration_line:
                    functions_called = libmkdep.match_function_call(line, fortran_names, globals.functions)
                    if len(functions_called) > 0:
                        if current_routine=="":
                            print "\nhm. not in a routine, but it looks like some function(s) are called:\n", functions_called
                            print "call not added to the tree. file=",filename,"line="
                            print line
                        else:
                            libmkdep.add2tree(globals.routines, current_routine, functions_called)

                
                    
        ## line done, reset
        long_line=""

    if libmkdep.show_warnings:
        if len(file_tabs) > 0:
            print "\nWarning "+filename+" has TAB character on the line(s) " + \
                  string.join(map(lambda s: "%d,"%s, file_tabs),"")
        if len(cont_cpp) > 0:
            print "\nWarning "+filename+" , line(s) " + \
                  string.join(map(lambda s: "%d,"%s, cont_cpp),"") + \
                  "\npossibly continuation over cpp directive"

    do_reparse=0
    deleted=1
    globals.clean_source_files2[filename] = (type, is_include, compflag, mtime, deps, do_reparse, deleted)

            
if libmkdep.debug:
    print "\nDone pass2,",lines,"statements."


libmkdep.find_uncalled()
    
libmkdep.save_maps()

if libmkdep.dump_modmap: libmkdep.write_modmap()

libmkdep.write_dependencies()
libmkdep.write_object_lists(globals.object_files)
libmkdep.write_makefile(globals.suffixes, use_mklib, f95, cc)

if globals.calltree:
    libmkdep.write_call_trees()
    libmkdep.install_files()

if cppwarn:
    print "\nInfo: there was a problem with cpp, so we reverted to not using cpp"
    print "if this is a problem, check the path to cpp and rerun"

